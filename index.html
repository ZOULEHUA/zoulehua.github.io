<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>五子棋 & 真心话大冒险</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
        }
        /* 导航按钮 */
        .nav {
            margin-top: 20px;
        }
        .nav button {
            margin: 5px;
            padding: 10px 20px;
            font-size: 16px;
        }
        /* 各功能区 */
        .section {
            display: none;
        }
        .active {
            display: block;
        }
        /* 五子棋相关样式 */
        canvas {
            background-color: #F0D9B5;
            border: 2px solid #333;
            margin-top: 20px;
        }
        #message {
            margin-top: 10px;
            font-size: 20px;
        }
        #resetButton, #undoButton {
            margin-top: 10px;
            font-size: 16px;
            padding: 5px 10px;
        }
        #gomokuControls {
            margin-top: 10px;
        }
        /* 真心话大冒险相关样式 */
        #tdButtons button {
            margin: 5px;
            padding: 10px 20px;
            font-size: 16px;
        }
        #trContent {
            margin-top: 20px;
            font-size: 18px;
            border: 1px solid #ccc;
            padding: 10px;
            width: 80%;
            margin-left: auto;
            margin-right: auto;
            min-height: 50px;
        }
        #tdVersion {
            margin-top: 10px;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <h1>五子棋 & 真心话大冒险</h1>
    <!-- 导航切换 -->
    <div class="nav">
        <button id="btnGomoku">五子棋</button>
        <button id="btnTruthDare">真心话大冒险</button>
    </div>

    <!-- 五子棋区 -->
    <div id="sectionGomoku" class="section active">
        <!-- 控制区 -->
        <div id="gomokuControls">
            <label>游戏模式:
                <select id="gameMode">
                    <option value="pvp">玩家对战</option>
                    <option value="pvai">玩家 vs AI</option>
                </select>
            </label>
            <span id="aiDifficultyContainer" style="display:none;">
                <label>难度:
                    <select id="aiDifficulty">
                        <option value="easy">简单</option>
                        <option value="medium">中级</option>
                        <option value="hard">高级</option>
                    </select>
                </label>
            </span>
            <button id="undoButton">悔棋</button>
        </div>
        <canvas id="board" width="600" height="600"></canvas>
        <div id="message">黑棋先手</div>
        <button id="resetButton">重置游戏</button>
    </div>

    <!-- 真心话大冒险区 -->
    <div id="sectionTruthDare" class="section">
        <div id="tdVersion">
            <label>版本:
                <select id="tdSelect">
                    <option value="standard">标准版</option>
                    <option value="adult">成人版</option>
                </select>
            </label>
        </div>
        <div id="tdButtons">
            <button id="btnTruth">真心话</button>
            <button id="btnDare">大冒险</button>
        </div>
        <div id="trContent">点击上方按钮获取内容</div>
    </div>

    <script>
        /* 导航切换代码 */
        document.getElementById("btnGomoku").addEventListener("click", function(){
            document.getElementById("sectionGomoku").classList.add("active");
            document.getElementById("sectionTruthDare").classList.remove("active");
        });
        document.getElementById("btnTruthDare").addEventListener("click", function(){
            document.getElementById("sectionGomoku").classList.remove("active");
            document.getElementById("sectionTruthDare").classList.add("active");
        });

        /* ----------------- 五子棋部分 ----------------- */
        const canvas = document.getElementById("board");
        const ctx = canvas.getContext("2d");
        const boardSize = 15;  // 棋盘为 15x15
        const cellSize = 40;   // 每格 40 像素
        const offset = 20;     // 边缘间距

        let board = [];        // 二维数组：0空，1黑，2白
        let currentPlayer = 1; // 1: 黑棋，2: 白棋 / AI
        let gameOver = false;
        let movesHistory = []; // 存储每一步落子 {row, col, player}

        // 获取游戏模式和 AI 难度
        let gameMode = document.getElementById("gameMode").value; // "pvp" 或 "pvai"
        let aiDifficulty = document.getElementById("aiDifficulty").value; // "easy", "medium", "hard"

        // 监听游戏模式变化
        document.getElementById("gameMode").addEventListener("change", function(){
            gameMode = this.value;
            if(gameMode === "pvai"){
                document.getElementById("aiDifficultyContainer").style.display = "inline";
            } else {
                document.getElementById("aiDifficultyContainer").style.display = "none";
            }
        });
        // 监听 AI 难度变化
        document.getElementById("aiDifficulty").addEventListener("change", function(){
            aiDifficulty = this.value;
        });

        // 初始化棋盘数据
        function initBoard() {
            board = [];
            for (let i = 0; i < boardSize; i++) {
                let row = [];
                for (let j = 0; j < boardSize; j++) {
                    row.push(0);
                }
                board.push(row);
            }
            currentPlayer = 1;
            gameOver = false;
            movesHistory = [];
            document.getElementById("message").innerText = "黑棋先手";
        }

        // 绘制棋盘与棋子
        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // 绘制背景
            ctx.fillStyle = "#F0D9B5";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // 绘制网格
            ctx.strokeStyle = "#333";
            for (let i = 0; i < boardSize; i++) {
                ctx.beginPath();
                ctx.moveTo(offset, offset + i * cellSize);
                ctx.lineTo(offset + (boardSize - 1) * cellSize, offset + i * cellSize);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(offset + i * cellSize, offset);
                ctx.lineTo(offset + i * cellSize, offset + (boardSize - 1) * cellSize);
                ctx.stroke();
            }
            // 绘制已有棋子
            for (let i = 0; i < boardSize; i++) {
                for (let j = 0; j < boardSize; j++) {
                    if (board[i][j] !== 0) {
                        drawStone(j, i, board[i][j]);
                    }
                }
            }
        }

        // 绘制棋子
        function drawStone(x, y, player) {
            const centerX = offset + x * cellSize;
            const centerY = offset + y * cellSize;
            ctx.beginPath();
            ctx.arc(centerX, centerY, cellSize/2 - 2, 0, 2*Math.PI);
            ctx.fillStyle = (player === 1) ? "black" : "white";
            ctx.fill();
            ctx.strokeStyle = "black";
            ctx.stroke();
        }

        // 检查胜利条件（横、竖、两对角线连续五子）
        function checkWin(x, y) {
            const player = board[y][x];
            if (player === 0) return false;
            const directions = [
                {dx: 1, dy: 0},
                {dx: 0, dy: 1},
                {dx: 1, dy: 1},
                {dx: 1, dy: -1}
            ];
            for (let d = 0; d < directions.length; d++) {
                let count = 1;
                const {dx, dy} = directions[d];
                let i = 1;
                while (true) {
                    const newX = x + dx * i;
                    const newY = y + dy * i;
                    if (newX < 0 || newX >= boardSize || newY < 0 || newY >= boardSize || board[newY][newX] !== player) break;
                    count++;
                    i++;
                }
                i = 1;
                while (true) {
                    const newX = x - dx * i;
                    const newY = y - dy * i;
                    if (newX < 0 || newX >= boardSize || newY < 0 || newY >= boardSize || board[newY][newX] !== player) break;
                    count++;
                    i++;
                }
                if (count >= 5) return true;
            }
            return false;
        }

        // 玩家下棋
        function playerMove(row, col) {
            if (gameOver || board[row][col] !== 0) return false;
            board[row][col] = currentPlayer;
            movesHistory.push({row: row, col: col, player: currentPlayer});
            drawBoard();
            if (checkWin(col, row)) {
                let winner = (currentPlayer === 1) ? "黑棋" : (gameMode === "pvai" ? "AI" : "白棋");
                document.getElementById("message").innerText = winner + " 赢了！";
                gameOver = true;
                return true;
            }
            // 切换玩家
            currentPlayer = (currentPlayer === 1 ? 2 : 1);
            if(gameMode === "pvp") {
                document.getElementById("message").innerText = (currentPlayer === 1 ? "黑棋" : "白棋") + " 先手";
            } else {
                document.getElementById("message").innerText = "玩家先手";
            }
            return true;
        }

        // 处理棋盘点击事件（仅在玩家回合有效）
        canvas.addEventListener("click", function(e) {
            if (gameOver) return;
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            const col = Math.round((clickX - offset) / cellSize);
            const row = Math.round((clickY - offset) / cellSize);
            if (col < 0 || col >= boardSize || row < 0 || row >= boardSize) return;
            if (!playerMove(row, col)) return;
            // 如果 PvAI 模式且游戏未结束，AI 走棋
            if (gameMode === "pvai" && !gameOver) {
                setTimeout(aiMove, 500); // 延时半秒模拟思考
            }
        });

        // AI 简单走法（随机走棋）
        function randomMove() {
            let emptyCells = [];
            for (let i = 0; i < boardSize; i++) {
                for (let j = 0; j < boardSize; j++) {
                    if (board[i][j] === 0) {
                        emptyCells.push({row: i, col: j});
                    }
                }
            }
            if (emptyCells.length === 0) return null;
            return emptyCells[Math.floor(Math.random() * emptyCells.length)];
        }

        // AI 查找必胜走法（如果能下一步赢，则走该步）
        function findWinningMove(player) {
            for (let i = 0; i < boardSize; i++) {
                for (let j = 0; j < boardSize; j++) {
                    if (board[i][j] === 0) {
                        board[i][j] = player;
                        if (checkWin(j, i)) {
                            board[i][j] = 0;
                            return {row: i, col: j};
                        }
                        board[i][j] = 0;
                    }
                }
            }
            return null;
        }

        /* ============== 新增：基于 Minimax 的 AI ============== */
        // 获取候选走法（仅考虑邻近已有棋子的空位）
        function getCandidateMoves() {
            let moves = [];
            for (let i = 0; i < boardSize; i++) {
                for (let j = 0; j < boardSize; j++) {
                    if (board[i][j] === 0) {
                        let found = false;
                        for (let di = -1; di <= 1; di++) {
                            for (let dj = -1; dj <= 1; dj++) {
                                let ni = i + di, nj = j + dj;
                                if (ni >= 0 && ni < boardSize && nj >= 0 && nj < boardSize) {
                                    if (board[ni][nj] !== 0) {
                                        moves.push({row: i, col: j});
                                        found = true;
                                        break;
                                    }
                                }
                            }
                            if (found) break;
                        }
                    }
                }
            }
            // 如果没有找到，则返回所有空位
            if (moves.length === 0) {
                for (let i = 0; i < boardSize; i++) {
                    for (let j = 0; j < boardSize; j++) {
                        if (board[i][j] === 0) moves.push({row: i, col: j});
                    }
                }
            }
            return moves;
        }

        // 评价局面：对每个棋子根据连续棋子数给予评分
        function evaluatePositionMinimax(x, y, player) {
            let total = 0;
            const directions = [
                {dx: 1, dy: 0},
                {dx: 0, dy: 1},
                {dx: 1, dy: 1},
                {dx: 1, dy: -1}
            ];
            for (let d = 0; d < directions.length; d++) {
                let count = 1;
                let block = 0;
                let {dx, dy} = directions[d];
                let i = 1;
                while (true) {
                    let nx = x + dx * i, ny = y + dy * i;
                    if (nx < 0 || nx >= boardSize || ny < 0 || ny >= boardSize) { block++; break; }
                    if (board[ny][nx] === player) {
                        count++;
                    } else if (board[ny][nx] !== 0) {
                        block++;
                        break;
                    } else {
                        break;
                    }
                    i++;
                }
                i = 1;
                while (true) {
                    let nx = x - dx * i, ny = y - dy * i;
                    if (nx < 0 || nx >= boardSize || ny < 0 || ny >= boardSize) { block++; break; }
                    if (board[ny][nx] === player) {
                        count++;
                    } else if (board[ny][nx] !== 0) {
                        block++;
                        break;
                    } else {
                        break;
                    }
                    i++;
                }
                if (count >= 5) return 100000;
                if (count === 4) {
                    total += (block === 0 ? 10000 : 1000);
                } else if (count === 3) {
                    total += (block === 0 ? 1000 : 100);
                } else if (count === 2) {
                    total += (block === 0 ? 100 : 10);
                } else {
                    total += 1;
                }
            }
            return total;
        }

        // 评价整个棋盘局面，从 AI 视角（玩家2）出发
        function evaluateBoard() {
            let score = 0;
            for (let i = 0; i < boardSize; i++) {
                for (let j = 0; j < boardSize; j++) {
                    if (board[i][j] === 2) {
                        score += evaluatePositionMinimax(j, i, 2);
                    } else if (board[i][j] === 1) {
                        score -= evaluatePositionMinimax(j, i, 1);
                    }
                }
            }
            return score;
        }

        // Minimax 算法（深度搜索，带 α-β 剪枝）
        function minimax(depth, alpha, beta, maximizingPlayer) {
            if (depth === 0 || gameOver) {
                return evaluateBoard();
            }
            let candidates = getCandidateMoves();
            if (maximizingPlayer) {
                let maxEval = -Infinity;
                for (let move of candidates) {
                    board[move.row][move.col] = 2;
                    let eval = minimax(depth - 1, alpha, beta, false);
                    board[move.row][move.col] = 0;
                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (let move of candidates) {
                    board[move.row][move.col] = 1;
                    let eval = minimax(depth - 1, alpha, beta, true);
                    board[move.row][move.col] = 0;
                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }

        // 在 hard 模式下，使用 Minimax 搜索选出最佳走法
        function bestMinimaxMove() {
            let bestScore = -Infinity;
            let bestMove = null;
            let candidates = getCandidateMoves();
            for (let move of candidates) {
                board[move.row][move.col] = 2;
                let score = minimax(2, -Infinity, Infinity, false);  // 这里搜索深度设为 2，可调整
                board[move.row][move.col] = 0;
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }
            return bestMove;
        }
        /* ============== AI 走棋函数 ============== */
        function aiMove() {
            if (gameOver) return;
            let move = null;
            if (aiDifficulty === "easy") {
                move = randomMove();
            } else if (aiDifficulty === "medium") {
                move = findWinningMove(2);
                if (!move) {
                    move = findWinningMove(1);
                }
                if (!move) {
                    move = randomMove();
                }
            } else if (aiDifficulty === "hard") {
                move = findWinningMove(2);
                if (!move) {
                    move = findWinningMove(1);
                }
                if (!move) {
                    move = bestMinimaxMove();
                    if (!move) move = randomMove();
                }
            }
            if (move) {
                board[move.row][move.col] = 2;
                movesHistory.push({row: move.row, col: move.col, player: 2});
                drawBoard();
                if (checkWin(move.col, move.row)) {
                    document.getElementById("message").innerText = "AI 赢了！";
                    gameOver = true;
                    return;
                }
                currentPlayer = 1;
                document.getElementById("message").innerText = "玩家先手";
            }
        }

        // 悔棋功能：PvP 悔一步，PvAI 悔玩家和 AI 的最后一步
        document.getElementById("undoButton").addEventListener("click", function() {
            if (movesHistory.length === 0 || gameOver) return;
            if (gameMode === "pvp") {
                let lastMove = movesHistory.pop();
                board[lastMove.row][lastMove.col] = 0;
                currentPlayer = lastMove.player;
            } else if (gameMode === "pvai") {
                if (movesHistory.length >= 2) {
                    let moveAI = movesHistory.pop();
                    board[moveAI.row][moveAI.col] = 0;
                    let movePlayer = movesHistory.pop();
                    board[movePlayer.row][movePlayer.col] = 0;
                    currentPlayer = 1;
                } else {
                    let lastMove = movesHistory.pop();
                    board[lastMove.row][lastMove.col] = 0;
                    currentPlayer = 1;
                }
            }
            gameOver = false;
            document.getElementById("message").innerText = (currentPlayer === 1 ? "黑棋" : (gameMode === "pvai" ? "AI" : "白棋")) + " 先手";
            drawBoard();
        });

        document.getElementById("resetButton").addEventListener("click", function() {
            initBoard();
            drawBoard();
        });

        initBoard();
        drawBoard();

        /* ----------------- 真心话大冒险部分 ----------------- */
        // 标准版内容
        const truthsStandard = [
            "你最害怕什么？",
            "说出你曾经做过最尴尬的一件事。",
            "你有没有暗恋过别人？是谁？"
        ];
        const daresStandard = [
            "模仿一个动物叫三次。",
            "大声唱一段流行歌曲。",
            "跳一段你最尴尬的舞蹈。"
        ];
        // 成人版内容（示例，可根据需要调整）
        const truthsAdult = [
            "你最后一次喝醉是什么时候？",
            "说说你做过的最疯狂的一件事。",
            "你有没有对某人抱有秘密的情愫？"
        ];
        const daresAdult = [
            "模仿一个性感动作持续10秒钟。",
            "大声说出你心中最挑逗的话语。",
            "做一个夸张的表情持续5秒钟。"
        ];

        // 随机获取数组中的一项
        function getRandomItem(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        document.getElementById("btnTruth").addEventListener("click", function() {
            const version = document.getElementById("tdSelect").value;
            let item = "";
            if(version === "adult") {
                item = getRandomItem(truthsAdult);
                document.getElementById("trContent").innerText = "真心话（成人版）：" + item;
            } else {
                item = getRandomItem(truthsStandard);
                document.getElementById("trContent").innerText = "真心话：" + item;
            }
        });
        document.getElementById("btnDare").addEventListener("click", function() {
            const version = document.getElementById("tdSelect").value;
            let item = "";
            if(version === "adult") {
                item = getRandomItem(daresAdult);
                document.getElementById("trContent").innerText = "大冒险（成人版）：" + item;
            } else {
                item = getRandomItem(daresStandard);
                document.getElementById("trContent").innerText = "大冒险：" + item;
            }
        });
    </script>
</body>
</html>
