<!DOCTYPE html>
<html>
<head>
    <title>智能五子棋-难度可选版</title>
    <style>
        body { font-family: Arial, sans-serif; background: #f0f0f0; }
        .control-panel { padding: 10px; background: #fff; margin: 10px; border-radius: 5px; }
        .control-group { display: inline-block; margin-right: 20px; }
        canvas { background: #FFF8DC; border: 1px solid #999; }
        #score { font-size: 16px; font-weight: bold; }
    </style>
</head>
<body>
    <div class="control-panel">
        <div class="control-group">
            <button id="modeBtn" onclick="toggleMode()">切换为双人模式</button>
        </div>
        <div class="control-group">
            <label>AI难度:</label>
            <input type="range" id="difficulty" min="1" max="10" value="5" onchange="updateDifficulty(this.value)">
        </div>
        <div class="control-group">
            <label>比赛规则:</label>
            <select id="ruleSelect" onchange="changeRule()">
                <option>三局两胜</option>
                <option>五局三胜</option>
                <option>十局六胜</option>
            </select>
        </div>
        <div class="control-group">
            <span id="score">分数 | 玩家1: 0  玩家2: 0</span>
        </div>
        <div class="control-group">
            <button onclick="startNewGame()">新游戏</button>
            <button onclick="undoMove()">悔棋</button>
        </div>
    </div>
    <canvas id="board"></canvas>

<script>
const CELL_SIZE = 30;
const BOARD_SIZE = 19;
let game = {
    board: Array(19).fill().map(() => Array(19).fill(0)),
    currentPlayer: 1,
    gameActive: false,
    mode: "ai",
    aiDifficulty: 5,
    scores: [0, 0],
    history: [],
    aiThinking: false
};

// 初始化Canvas
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
canvas.width = BOARD_SIZE * CELL_SIZE;
canvas.height = BOARD_SIZE * CELL_SIZE;

// 绘制棋盘
function drawBoard() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = '#000';
    
    // 绘制网格
    for (let i = 0; i < BOARD_SIZE; i++) {
        const pos = i * CELL_SIZE + CELL_SIZE/2;
        ctx.beginPath();
        ctx.moveTo(CELL_SIZE/2, pos);
        ctx.lineTo(canvas.width - CELL_SIZE/2, pos);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(pos, CELL_SIZE/2);
        ctx.lineTo(pos, canvas.height - CELL_SIZE/2);
        ctx.stroke();
    }
    
    // 星位
    [[3,3], [3,15], [15,3], [15,15], [9,9]].forEach(([x,y]) => {
        ctx.beginPath();
        ctx.arc(x*CELL_SIZE + CELL_SIZE/2, y*CELL_SIZE + CELL_SIZE/2, 3, 0, Math.PI*2);
        ctx.fill();
    });
}

// 放置棋子
function placePiece(x, y) {
    ctx.beginPath();
    ctx.arc(x*CELL_SIZE + CELL_SIZE/2, y*CELL_SIZE + CELL_SIZE/2, 12, 0, Math.PI*2);
    ctx.fillStyle = game.currentPlayer === 1 ? 'black' : 'white';
    ctx.fill();
    game.board[y][x] = game.currentPlayer;
    game.history.push([x, y]);
    game.currentPlayer = game.currentPlayer === 1 ? 2 : 1;
}

// 检查胜利
function checkWin(x, y) {
    const player = game.board[y][x];
    const directions = [[1,0], [0,1], [1,1], [1,-1]];
    
    for (const [dx, dy] of directions) {
        let count = 1;
        let step = 1;
        while (true) {
            const nx = x + dx * step;
            const ny = y + dy * step;
            if (nx < 0 || nx >= 19 || ny < 0 || ny >= 19 || game.board[ny][nx] !== player) break;
            count++;
            step++;
        }
        step = 1;
        while (true) {
            const nx = x - dx * step;
            const ny = y - dy * step;
            if (nx < 0 || nx >= 19 || ny < 0 || ny >= 19 || game.board[ny][nx] !== player) break;
            count++;
            step++;
        }
        if (count >= 5) return true;
    }
    return false;
}

// AI逻辑
function aiMove() {
    if (!game.gameActive || game.aiThinking) return;
    game.aiThinking = true;
    
    setTimeout(() => {
        const empty = [];
        for (let y = 0; y < 19; y++) {
            for (let x = 0; x < 19; x++) {
                if (game.board[y][x] === 0) empty.push([x, y]);
            }
        }
        const [x, y] = empty[Math.floor(Math.random()*empty.length)];
        placePiece(x, y);
        if (checkWin(x, y)) gameOver(2);
        game.aiThinking = false;
    }, 500);
}

// 事件处理
canvas.addEventListener('click', (e) => {
    if (!game.gameActive || game.aiThinking) return;
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left - CELL_SIZE/2) / CELL_SIZE);
    const y = Math.floor((e.clientY - rect.top - CELL_SIZE/2) / CELL_SIZE);
    
    if (x >= 0 && x < 19 && y >= 0 && y < 19 && game.board[y][x] === 0) {
        placePiece(x, y);
        if (checkWin(x, y)) {
            gameOver(game.currentPlayer === 1 ? 2 : 1);
        } else if (game.mode === "ai") {
            aiMove();
        }
    }
});

// 其他功能函数
function startNewGame() {
    game.board = Array(19).fill().map(() => Array(19).fill(0));
    game.currentPlayer = Math.random() < 0.5 ? 1 : 2;
    game.gameActive = true;
    game.history = [];
    drawBoard();
    if (game.mode === "ai" && game.currentPlayer === 2) aiMove();
}

function updateScore() {
    document.getElementById('score').textContent = 
        `分数 | 玩家1: ${game.scores[0]}  玩家2: ${game.scores[1]}`;
}

function gameOver(winner) {
    game.gameActive = false;
    game.scores[winner-1]++;
    updateScore();
    alert(`玩家${winner}获胜!`);
}

// 控制函数
function toggleMode() {
    game.mode = game.mode === "ai" ? "human" : "ai";
    document.getElementById('modeBtn').textContent = 
        `切换为${game.mode === 'ai' ? '双人' : 'AI'}模式`;
    startNewGame();
}

function updateDifficulty(v) { game.aiDifficulty = parseInt(v); }
function changeRule() { /* 规则实现需扩展 */ }
function undoMove() { /* 悔棋功能需扩展 */ }

// 初始化
drawBoard();
</script>
</body>
</html>
